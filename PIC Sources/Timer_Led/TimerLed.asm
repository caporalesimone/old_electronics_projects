;  ASM code generated by mikroVirtualMachine for PIC - V. 6.2.1.0
;  Date/Time: 11/09/2007 11.27.43
;  Info: http://www.mikroelektronika.co.yu


; ADDRESS	OPCODE	ASM
; ----------------------------------------------
$0000	$29EE			GOTO	_main
$0004	$	_interrupt:
$0004	$00CF			MOVWF	STACK_15
$0005	$0E03			SWAPF	STATUS, 0
$0006	$0183			CLRF	STATUS
$0007	$0095			MOVWF	?saveSTATUS
$0008	$0804			MOVF	FSR, 0
$0009	$0094			MOVWF	?saveFSR
$000A	$080A			MOVF	PCLATH, 0
$000B	$0096			MOVWF	?savePCLATH
$000C	$018A			CLRF	PCLATH
;TimerLed.c,26 :: 		void interrupt ()
;TimerLed.c,28 :: 		uiContTmp++;
$000D	$0A8C			INCF	_uiContTmp, 1
$000E	$1903			BTFSC	STATUS, Z
$000F	$0A8D			INCF	_uiContTmp+1, 1
;TimerLed.c,29 :: 		TMR0 = 96;
$0010	$3060			MOVLW	96
$0011	$0081			MOVWF	TMR0
;TimerLed.c,30 :: 		INTCON = 0x20;       // Set T0IE, clear T0IF
$0012	$3020			MOVLW	32
$0013	$008B			MOVWF	INTCON
;TimerLed.c,31 :: 		}
$0014	$	L_Interrupt_end:
$0014	$0816			MOVF	?savePCLATH, 0
$0015	$008A			MOVWF	PCLATH
$0016	$0814			MOVF	?saveFSR, 0
$0017	$0084			MOVWF	FSR
$0018	$0E15			SWAPF	?saveSTATUS, 0
$0019	$0083			MOVWF	STATUS
$001A	$0ECF			SWAPF	STACK_15, 1
$001B	$0E4F			SWAPF	STACK_15, 0
$001C	$0009			RETFIE
$001D	$	_Div_16x16_S_L:
$001D	$1303			BCF	STATUS, RP1
$001E	$1283			BCF	STATUS, RP0
$001F	$0D41			RLF	STACK_1, W
$0020	$0DC8			RLF	STACK_8, F
$0021	$0DC9			RLF	STACK_9, F
$0022	$0844			MOVF	STACK_4, W
$0023	$02C8			SUBWF	STACK_8, F
$0024	$0845			MOVF	STACK_5, W
$0025	$1C03			BTFSS	STATUS, C
$0026	$0F45			INCFSZ	STACK_5, W
$0027	$02C9			SUBWF	STACK_9, F
$0028	$0DC0			RLF	STACK_0, F
$0029	$0DC1			RLF	STACK_1, F
$002A	$300F			MOVLW	15
$002B	$00CC			MOVWF	STACK_12
$002C	$0D41			RLF	STACK_1, W
$002D	$0DC8			RLF	STACK_8, F
$002E	$0DC9			RLF	STACK_9, F
$002F	$0844			MOVF	STACK_4, W
$0030	$1C40			BTFSS	STACK_0, 0
$0031	$2838			GOTO	$+7
$0032	$02C8			SUBWF	STACK_8, F
$0033	$0845			MOVF	STACK_5, W
$0034	$1C03			BTFSS	STATUS, C
$0035	$0F45			INCFSZ	STACK_5, W
$0036	$02C9			SUBWF	STACK_9, F
$0037	$283D			GOTO	$+6
$0038	$07C8			ADDWF	STACK_8, F
$0039	$0845			MOVF	STACK_5, W
$003A	$1803			BTFSC	STATUS, C
$003B	$0F45			INCFSZ	STACK_5, W
$003C	$07C9			ADDWF	STACK_9, F
$003D	$0DC0			RLF	STACK_0, F
$003E	$0DC1			RLF	STACK_1, F
$003F	$0BCC			DECFSZ	STACK_12, F
$0040	$282C			GOTO	$-20
$0041	$1840			BTFSC	STACK_0, 0
$0042	$2849			GOTO	$+7
$0043	$0844			MOVF	STACK_4, W
$0044	$07C8			ADDWF	STACK_8, F
$0045	$0845			MOVF	STACK_5, W
$0046	$1803			BTFSC	STATUS, C
$0047	$0F45			INCFSZ	STACK_5, W
$0048	$07C9			ADDWF	STACK_9, F
$0049	$0000			NOP
$004A	$0008			RETURN
$004B	$	_EEprom_read:
$004B	$1303			BCF	STATUS, RP1
$004C	$1283			BCF	STATUS, RP0
$004D	$0824			MOVF	FARG_EEprom_read+0, 0
$004E	$0089			MOVWF	EEADR
$004F	$1683			BSF	STATUS, RP0
$0050	$1388			BCF	EECON1, 7
$0051	$1408			BSF	EECON1, 0
$0052	$1283			BCF	STATUS, RP0
$0053	$0808			MOVF	EEDATA, 0
$0054	$00C0			MOVWF	STACK_0
$0055	$0008			RETURN
$0056	$	_Div_16x16_U:
$0056	$1303			BCF	STATUS, RP1
$0057	$1283			BCF	STATUS, RP0
$0058	$01C8			CLRF	STACK_8
$0059	$01C9			CLRF	STACK_9
$005A	$3010			MOVLW	16
$005B	$00CC			MOVWF	STACK_12
$005C	$0D41			RLF	STACK_1, W
$005D	$0DC8			RLF	STACK_8, F
$005E	$0DC9			RLF	STACK_9, F
$005F	$0844			MOVF	STACK_4, W
$0060	$02C8			SUBWF	STACK_8, F
$0061	$0845			MOVF	STACK_5, W
$0062	$1C03			BTFSS	STATUS, C
$0063	$0F45			INCFSZ	STACK_5, W
$0064	$02C9			SUBWF	STACK_9, F
$0065	$1803			BTFSC	STATUS, C
$0066	$286E			GOTO	$+8
$0067	$0844			MOVF	STACK_4, W
$0068	$07C8			ADDWF	STACK_8, F
$0069	$0845			MOVF	STACK_5, W
$006A	$1803			BTFSC	STATUS, C
$006B	$0F45			INCFSZ	STACK_5, W
$006C	$07C9			ADDWF	STACK_9, F
$006D	$1003			BCF	STATUS, C
$006E	$0DC0			RLF	STACK_0, F
$006F	$0DC1			RLF	STACK_1, F
$0070	$0BCC			DECFSZ	STACK_12, F
$0071	$285C			GOTO	$-21
$0072	$0008			RETURN
$0073	$	_EEprom_write:
$0073	$0000			NOP
$0074	$	L_EEprom_write_0:
$0074	$1303			BCF	STATUS, RP1
$0075	$1683			BSF	STATUS, RP0
$0076	$1C88			BTFSS	EECON1, 1
$0077	$287A			GOTO	L_EEprom_write_1
$0078	$0000			NOP
$0079	$2874			GOTO	L_EEprom_write_0
$007A	$	L_EEprom_write_1:
$007A	$0824			MOVF	FARG_EEprom_write+0, 0
$007B	$1283			BCF	STATUS, RP0
$007C	$0089			MOVWF	EEADR
$007D	$0825			MOVF	FARG_EEprom_write+1, 0
$007E	$0088			MOVWF	EEDATA
$007F	$1683			BSF	STATUS, RP0
$0080	$1388			BCF	EECON1, 7
$0081	$1508			BSF	EECON1, 2
$0082	$138B			BCF	INTCON, 7
$0083	$3055			MOVLW	85
$0084	$0089			MOVWF	EECON2
$0085	$30AA			MOVLW	170
$0086	$0089			MOVWF	EECON2
$0087	$1488			BSF	EECON1, 1
$0088	$178B			BSF	INTCON, 7
$0089	$1108			BCF	EECON1, 2
$008A	$0008			RETURN
$008B	$	_Div_16x16_S:
$008B	$1303			BCF	STATUS, RP1
$008C	$1283			BCF	STATUS, RP0
$008D	$01CD			CLRF	STACK_13
$008E	$01C9			CLRF	STACK_9
$008F	$01C8			CLRF	STACK_8
$0090	$0841			MOVF	STACK_1, W
$0091	$0440			IORWF	STACK_0, W
$0092	$1903			BTFSC	STATUS, Z
$0093	$3400			RETLW	0
$0094	$0841			MOVF	STACK_1, W
$0095	$0645			XORWF	STACK_5, W
$0096	$00CA			MOVWF	STACK_10
$0097	$1BCA			BTFSC	STACK_10, 7
$0098	$09CD			COMF	STACK_13, F
$0099	$01CB			CLRF	STACK_11
$009A	$1FC5			BTFSS	STACK_5, 7
$009B	$28A1			GOTO	$+6
$009C	$09C4			COMF	STACK_4, F
$009D	$09C5			COMF	STACK_5, F
$009E	$0AC4			INCF	STACK_4, F
$009F	$1903			BTFSC	STATUS, Z
$00A0	$0AC5			INCF	STACK_5, F
$00A1	$1FC1			BTFSS	STACK_1, 7
$00A2	$28A8			GOTO	$+6
$00A3	$09C0			COMF	STACK_0, F
$00A4	$09C1			COMF	STACK_1, F
$00A5	$0AC0			INCF	STACK_0, F
$00A6	$1903			BTFSC	STATUS, Z
$00A7	$0AC1			INCF	STACK_1, F
$00A8	$0841			MOVF	STACK_1, W
$00A9	$0445			IORWF	STACK_5, W
$00AA	$00CA			MOVWF	STACK_10
$00AB	$1BCA			BTFSC	STACK_10, 7
$00AC	$28BD			GOTO	$+17
$00AD	$201D			CALL	_Div_16x16_S_L
$00AE	$184B			BTFSC	STACK_11, 0
$00AF	$28D0			GOTO	$+33
$00B0	$1FCD			BTFSS	STACK_13, 7
$00B1	$3400			RETLW	0
$00B2	$09C0			COMF	STACK_0, F
$00B3	$09C1			COMF	STACK_1, F
$00B4	$0AC0			INCF	STACK_0, F
$00B5	$1903			BTFSC	STATUS, Z
$00B6	$0AC1			INCF	STACK_1, F
$00B7	$09C8			COMF	STACK_8, F
$00B8	$09C9			COMF	STACK_9, F
$00B9	$0AC8			INCF	STACK_8, F
$00BA	$1903			BTFSC	STATUS, Z
$00BB	$0AC9			INCF	STACK_9, F
$00BC	$3400			RETLW	0
$00BD	$1FC5			BTFSS	STACK_5, 7
$00BE	$28CC			GOTO	$+14
$00BF	$1BC1			BTFSC	STACK_1, 7
$00C0	$28C8			GOTO	$+8
$00C1	$0841			MOVF	STACK_1, W
$00C2	$00C9			MOVWF	STACK_9
$00C3	$0840			MOVF	STACK_0, W
$00C4	$00C8			MOVWF	STACK_8
$00C5	$01C1			CLRF	STACK_1
$00C6	$01C0			CLRF	STACK_0
$00C7	$28B0			GOTO	$-23
$00C8	$01C1			CLRF	STACK_1
$00C9	$01C0			CLRF	STACK_0
$00CA	$0AC0			INCF	STACK_0, F
$00CB	$3400			RETLW	0
$00CC	$09C1			COMF	STACK_1, F
$00CD	$09C0			COMF	STACK_0, F
$00CE	$0ACB			INCF	STACK_11, F
$00CF	$28AD			GOTO	$-34
$00D0	$0AC8			INCF	STACK_8, F
$00D1	$1903			BTFSC	STATUS, Z
$00D2	$0AC9			INCF	STACK_9, F
$00D3	$0844			MOVF	STACK_4, W
$00D4	$0248			SUBWF	STACK_8, W
$00D5	$1D03			BTFSS	STATUS, Z
$00D6	$28B0			GOTO	$-38
$00D7	$0845			MOVF	STACK_5, W
$00D8	$0249			SUBWF	STACK_9, W
$00D9	$1D03			BTFSS	STATUS, Z
$00DA	$28B0			GOTO	$-42
$00DB	$01C9			CLRF	STACK_9
$00DC	$01C8			CLRF	STACK_8
$00DD	$0AC0			INCF	STACK_0, F
$00DE	$1903			BTFSC	STATUS, Z
$00DF	$0AC1			INCF	STACK_1, F
$00E0	$1FC1			BTFSS	STACK_1, 7
$00E1	$28B0			GOTO	$-49
$00E2	$0000			NOP
$00E3	$34FF			RETLW	255
$00E4	$0008			RETURN
$00E5	$	_InitMCU:
;TimerLed.c,34 :: 		void InitMCU (void) {
;TimerLed.c,36 :: 		PORTB = 0;
$00E5	$1303			BCF	STATUS, RP1
$00E6	$1283			BCF	STATUS, RP0
$00E7	$0186			CLRF	PORTB, 1
;TimerLed.c,37 :: 		PORTA = 0;
$00E8	$0185			CLRF	PORTA, 1
;TimerLed.c,38 :: 		TRISA = 0xFF; // INPUT
$00E9	$30FF			MOVLW	255
$00EA	$1683			BSF	STATUS, RP0
$00EB	$0085			MOVWF	TRISA
;TimerLed.c,39 :: 		TRISB = 0x00; // OUTPUT
$00EC	$0186			CLRF	TRISB, 1
;TimerLed.c,42 :: 		OPTION_REG = 0x84;   // Assign prescaler to TMR0
$00ED	$3084			MOVLW	132
$00EE	$0081			MOVWF	OPTION_REG
;TimerLed.c,43 :: 		uiContTmp = 0;
$00EF	$018C			CLRF	_uiContTmp
$00F0	$018D			CLRF	_uiContTmp+1
;TimerLed.c,44 :: 		TMR0 = 96;
$00F1	$3060			MOVLW	96
$00F2	$1283			BCF	STATUS, RP0
$00F3	$0081			MOVWF	TMR0
;TimerLed.c,45 :: 		}
$00F4	$0008			RETURN
$00F5	$	_Carica_Sec:
;TimerLed.c,101 :: 		int Carica_Sec(){
;TimerLed.c,104 :: 		sec_letti = Eeprom_Read(1);
$00F5	$3001			MOVLW	1
$00F6	$1303			BCF	STATUS, RP1
$00F7	$1283			BCF	STATUS, RP0
$00F8	$00A4			MOVWF	FARG_EEprom_read+0
$00F9	$204B			CALL	_EEprom_read
$00FA	$0840			MOVF	STACK_0, 0
$00FB	$009F			MOVWF	Carica_Sec_sec_letti_L0
$00FC	$01A0			CLRF	Carica_Sec_sec_letti_L0+1
;TimerLed.c,105 :: 		Delay_ms(250);
$00FD	$3002			MOVLW	2
$00FE	$00CC			MOVWF	STACK_12
$00FF	$30FF			MOVLW	255
$0100	$00CB			MOVWF	STACK_11
$0101	$30FF			MOVLW	255
$0102	$00CA			MOVWF	STACK_10
$0103	$0BCC			DECFSZ	STACK_12, F
$0104	$2906			GOTO	$+2
$0105	$290D			GOTO	$+8
$0106	$0BCB			DECFSZ	STACK_11, F
$0107	$2909			GOTO	$+2
$0108	$290C			GOTO	$+4
$0109	$0BCA			DECFSZ	STACK_10, F
$010A	$2909			GOTO	$-1
$010B	$2906			GOTO	$-5
$010C	$2903			GOTO	$-9
$010D	$3046			MOVLW	70
$010E	$00CB			MOVWF	STACK_11
$010F	$30FF			MOVLW	255
$0110	$00CA			MOVWF	STACK_10
$0111	$0BCB			DECFSZ	STACK_11, F
$0112	$2914			GOTO	$+2
$0113	$2917			GOTO	$+4
$0114	$0BCA			DECFSZ	STACK_10, F
$0115	$2914			GOTO	$-1
$0116	$2911			GOTO	$-5
$0117	$30CF			MOVLW	207
$0118	$00CA			MOVWF	STACK_10
$0119	$0BCA			DECFSZ	STACK_10, F
$011A	$2919			GOTO	$-1
$011B	$0000			NOP
;TimerLed.c,106 :: 		sec_letti = sec_letti + (256 * Eeprom_Read(3));
$011C	$3003			MOVLW	3
$011D	$00A4			MOVWF	FARG_EEprom_read+0
$011E	$204B			CALL	_EEprom_read
$011F	$0840			MOVF	STACK_0, 0
$0120	$00C1			MOVWF	STACK_0+1
$0121	$01C0			CLRF	STACK_0
$0122	$081F			MOVF	Carica_Sec_sec_letti_L0, 0
$0123	$07C0			ADDWF	STACK_0, 1
$0124	$0820			MOVF	Carica_Sec_sec_letti_L0+1, 0
$0125	$1803			BTFSC	STATUS, C
$0126	$3F01			ADDLW	1
$0127	$07C1			ADDWF	STACK_0+1, 1
$0128	$0840			MOVF	STACK_0, 0
$0129	$009F			MOVWF	Carica_Sec_sec_letti_L0
$012A	$0841			MOVF	STACK_0+1, 0
$012B	$00A0			MOVWF	Carica_Sec_sec_letti_L0+1
;TimerLed.c,107 :: 		return sec_letti;
;TimerLed.c,108 :: 		}
$012C	$0008			RETURN
$012D	$	_Enable_Output:
;TimerLed.c,48 :: 		void Enable_Output (char OutEnabled){
;TimerLed.c,49 :: 		if (OutEnabled == 1)
$012D	$1303			BCF	STATUS, RP1
$012E	$1283			BCF	STATUS, RP0
$012F	$081F			MOVF	FARG_Enable_Output+0, 0
$0130	$3A01			XORLW	1
$0131	$1D03			BTFSS	STATUS, Z
$0132	$2936			GOTO	L_Enable_Output_0
;TimerLed.c,50 :: 		ucOutEnabled = 128;
$0133	$3080			MOVLW	128
$0134	$008E			MOVWF	_ucOutEnabled
$0135	$2937			GOTO	L_Enable_Output_1
$0136	$	L_Enable_Output_0:
;TimerLed.c,52 :: 		ucOutEnabled = 0;
$0136	$018E			CLRF	_ucOutEnabled, 1
$0137	$	L_Enable_Output_1:
;TimerLed.c,53 :: 		}
$0137	$0008			RETURN
$0138	$	_Abilita_Timer:
;TimerLed.c,56 :: 		void Abilita_Timer (char TimerEnabled) {
;TimerLed.c,57 :: 		if (TimerEnabled == 1)
$0138	$1303			BCF	STATUS, RP1
$0139	$1283			BCF	STATUS, RP0
$013A	$081F			MOVF	FARG_Abilita_Timer+0, 0
$013B	$3A01			XORLW	1
$013C	$1D03			BTFSS	STATUS, Z
$013D	$2941			GOTO	L_Abilita_Timer_2
;TimerLed.c,58 :: 		INTCON = 0xA0; // Enable TMRO interrupt
$013E	$30A0			MOVLW	160
$013F	$008B			MOVWF	INTCON
$0140	$2942			GOTO	L_Abilita_Timer_3
$0141	$	L_Abilita_Timer_2:
;TimerLed.c,60 :: 		INTCON = 0x00; // Disable TMRO interrupt
$0141	$018B			CLRF	INTCON, 1
$0142	$	L_Abilita_Timer_3:
;TimerLed.c,61 :: 		}
$0142	$0008			RETURN
$0143	$	_DisplayNum:
;TimerLed.c,63 :: 		void DisplayNum (void)
;TimerLed.c,71 :: 		if (uiSecondi_Attuale > 0) {
$0143	$3080			MOVLW	128
$0144	$1303			BCF	STATUS, RP1
$0145	$1283			BCF	STATUS, RP0
$0146	$00C0			MOVWF	STACK_0
$0147	$3080			MOVLW	128
$0148	$0610			XORWF	_uiSecondi_Attuale+1, 0
$0149	$0240			SUBWF	STACK_0, 0
$014A	$1D03			BTFSS	STATUS, Z
$014B	$294E			GOTO	L_DisplayNum_52
$014C	$080F			MOVF	_uiSecondi_Attuale, 0
$014D	$3C00			SUBLW	0
$014E	$	L_DisplayNum_52:
$014E	$1803			BTFSC	STATUS, C
$014F	$2987			GOTO	L_DisplayNum_4
;TimerLed.c,73 :: 		ucSecondi_Minuti = uiSecondi / 60;
$0150	$303C			MOVLW	60
$0151	$00C4			MOVWF	STACK_4
$0152	$3000			MOVLW	0
$0153	$00C5			MOVWF	STACK_4+1
$0154	$080F			MOVF	_uiSecondi_Attuale, 0
$0155	$00C0			MOVWF	STACK_0
$0156	$0810			MOVF	_uiSecondi_Attuale+1, 0
$0157	$00C1			MOVWF	STACK_0+1
$0158	$2056			CALL	_div_16x16_u
$0159	$0840			MOVF	STACK_0, 0
$015A	$00A1			MOVWF	DisplayNum_ucSecondi_Minuti_L0
;TimerLed.c,74 :: 		uiSecondi =  uiSecondi % 60;
$015B	$303C			MOVLW	60
$015C	$00C4			MOVWF	STACK_4
$015D	$3000			MOVLW	0
$015E	$00C5			MOVWF	STACK_4+1
$015F	$080F			MOVF	_uiSecondi_Attuale, 0
$0160	$00C0			MOVWF	STACK_0
$0161	$0810			MOVF	_uiSecondi_Attuale+1, 0
$0162	$00C1			MOVWF	STACK_0+1
$0163	$2056			CALL	_div_16x16_u
$0164	$0848			MOVF	STACK_8, 0
$0165	$00C0			MOVWF	STACK_0
$0166	$0849			MOVF	STACK_9, 0
$0167	$00C1			MOVWF	STACK_1
$0168	$0840			MOVF	STACK_0, 0
$0169	$00A2			MOVWF	FLOC_DisplayNum+3
$016A	$0841			MOVF	STACK_0+1, 0
$016B	$00A3			MOVWF	FLOC_DisplayNum+4
;TimerLed.c,75 :: 		ucSecondi_Decine = uiSecondi / 10;
$016C	$300A			MOVLW	10
$016D	$00C4			MOVWF	STACK_4
$016E	$3000			MOVLW	0
$016F	$00C5			MOVWF	STACK_4+1
$0170	$0822			MOVF	FLOC_DisplayNum+3, 0
$0171	$00C0			MOVWF	STACK_0
$0172	$0823			MOVF	FLOC_DisplayNum+4, 0
$0173	$00C1			MOVWF	STACK_0+1
$0174	$2056			CALL	_div_16x16_u
$0175	$0840			MOVF	STACK_0, 0
$0176	$00A0			MOVWF	DisplayNum_ucSecondi_Decine_L0
;TimerLed.c,76 :: 		ucSecondi_Unita = uiSecondi % 10;
$0177	$300A			MOVLW	10
$0178	$00C4			MOVWF	STACK_4
$0179	$3000			MOVLW	0
$017A	$00C5			MOVWF	STACK_4+1
$017B	$0822			MOVF	FLOC_DisplayNum+3, 0
$017C	$00C0			MOVWF	STACK_0
$017D	$0823			MOVF	FLOC_DisplayNum+4, 0
$017E	$00C1			MOVWF	STACK_0+1
$017F	$2056			CALL	_div_16x16_u
$0180	$0848			MOVF	STACK_8, 0
$0181	$00C0			MOVWF	STACK_0
$0182	$0849			MOVF	STACK_9, 0
$0183	$00C1			MOVWF	STACK_1
$0184	$0840			MOVF	STACK_0, 0
$0185	$009F			MOVWF	DisplayNum_ucSecondi_Unita_L0
;TimerLed.c,77 :: 		} else {
$0186	$298A			GOTO	L_DisplayNum_5
$0187	$	L_DisplayNum_4:
;TimerLed.c,78 :: 		ucSecondi_Minuti = 0;
$0187	$01A1			CLRF	DisplayNum_ucSecondi_Minuti_L0, 1
;TimerLed.c,79 :: 		ucSecondi_Decine = 0;
$0188	$01A0			CLRF	DisplayNum_ucSecondi_Decine_L0, 1
;TimerLed.c,80 :: 		ucSecondi_Unita = 0;
$0189	$019F			CLRF	DisplayNum_ucSecondi_Unita_L0, 1
;TimerLed.c,81 :: 		}
$018A	$	L_DisplayNum_5:
;TimerLed.c,83 :: 		switch(ucNumDisplay) {
$018A	$29A6			GOTO	L_DisplayNum_6
;TimerLed.c,84 :: 		case 0: // Display delle unità di secondi
$018B	$	L_DisplayNum_8:
;TimerLed.c,85 :: 		DISPLAY_VALUE = ucSecondi_Unita;
$018B	$081F			MOVF	DisplayNum_ucSecondi_Unita_L0, 0
$018C	$0086			MOVWF	PORTB
;TimerLed.c,86 :: 		DISPLAY_VALUE = DISPLAY_VALUE + 16 + ucOutEnabled;
$018D	$3010			MOVLW	16
$018E	$0706			ADDWF	PORTB, 0
$018F	$00C0			MOVWF	STACK_0
$0190	$080E			MOVF	_ucOutEnabled, 0
$0191	$0740			ADDWF	STACK_0, 0
$0192	$0086			MOVWF	PORTB
;TimerLed.c,87 :: 		break;
$0193	$29B2			GOTO	L_DisplayNum_7
;TimerLed.c,88 :: 		case 1: // Display delle decine di secondi
$0194	$	L_DisplayNum_9:
;TimerLed.c,89 :: 		DISPLAY_VALUE = ucSecondi_Decine;
$0194	$0820			MOVF	DisplayNum_ucSecondi_Decine_L0, 0
$0195	$0086			MOVWF	PORTB
;TimerLed.c,90 :: 		DISPLAY_VALUE = DISPLAY_VALUE + 32 + ucOutEnabled;
$0196	$3020			MOVLW	32
$0197	$0706			ADDWF	PORTB, 0
$0198	$00C0			MOVWF	STACK_0
$0199	$080E			MOVF	_ucOutEnabled, 0
$019A	$0740			ADDWF	STACK_0, 0
$019B	$0086			MOVWF	PORTB
;TimerLed.c,91 :: 		break;
$019C	$29B2			GOTO	L_DisplayNum_7
;TimerLed.c,92 :: 		case 2: // Display dei minuti
$019D	$	L_DisplayNum_10:
;TimerLed.c,93 :: 		DISPLAY_VALUE = ucSecondi_Minuti;
$019D	$0821			MOVF	DisplayNum_ucSecondi_Minuti_L0, 0
$019E	$0086			MOVWF	PORTB
;TimerLed.c,94 :: 		DISPLAY_VALUE = DISPLAY_VALUE + 64 + ucOutEnabled;
$019F	$3040			MOVLW	64
$01A0	$0706			ADDWF	PORTB, 0
$01A1	$00C0			MOVWF	STACK_0
$01A2	$080E			MOVF	_ucOutEnabled, 0
$01A3	$0740			ADDWF	STACK_0, 0
$01A4	$0086			MOVWF	PORTB
;TimerLed.c,95 :: 		break;
$01A5	$29B2			GOTO	L_DisplayNum_7
;TimerLed.c,96 :: 		}
$01A6	$	L_DisplayNum_6:
$01A6	$0811			MOVF	_ucNumDisplay, 0
$01A7	$3A00			XORLW	0
$01A8	$1903			BTFSC	STATUS, Z
$01A9	$298B			GOTO	L_DisplayNum_8
$01AA	$0811			MOVF	_ucNumDisplay, 0
$01AB	$3A01			XORLW	1
$01AC	$1903			BTFSC	STATUS, Z
$01AD	$2994			GOTO	L_DisplayNum_9
$01AE	$0811			MOVF	_ucNumDisplay, 0
$01AF	$3A02			XORLW	2
$01B0	$1903			BTFSC	STATUS, Z
$01B1	$299D			GOTO	L_DisplayNum_10
$01B2	$	L_DisplayNum_7:
;TimerLed.c,97 :: 		ucNumDisplay++;
$01B2	$0A91			INCF	_ucNumDisplay, 1
;TimerLed.c,98 :: 		if (ucNumDisplay >= 3) ucNumDisplay = 0;
$01B3	$3003			MOVLW	3
$01B4	$0211			SUBWF	_ucNumDisplay, 0
$01B5	$1C03			BTFSS	STATUS, C
$01B6	$29B8			GOTO	L_DisplayNum_11
$01B7	$0191			CLRF	_ucNumDisplay, 1
$01B8	$	L_DisplayNum_11:
;TimerLed.c,99 :: 		} // END void DisplayNum (void)
$01B8	$0008			RETURN
$01B9	$	_Salva_Sec:
;TimerLed.c,110 :: 		void Salva_Sec(int Secondi){
;TimerLed.c,113 :: 		EEprom_Write(1, Secondi & 0b11111111);
$01B9	$3001			MOVLW	1
$01BA	$1303			BCF	STATUS, RP1
$01BB	$1283			BCF	STATUS, RP0
$01BC	$00A4			MOVWF	FARG_EEprom_write+0
$01BD	$30FF			MOVLW	255
$01BE	$051F			ANDWF	FARG_Salva_Sec+0, 0
$01BF	$00A5			MOVWF	FARG_EEprom_write+1
$01C0	$2073			CALL	_EEprom_write
;TimerLed.c,114 :: 		Delay_ms(250);
$01C1	$3002			MOVLW	2
$01C2	$00CC			MOVWF	STACK_12
$01C3	$30FF			MOVLW	255
$01C4	$00CB			MOVWF	STACK_11
$01C5	$30FF			MOVLW	255
$01C6	$00CA			MOVWF	STACK_10
$01C7	$0BCC			DECFSZ	STACK_12, F
$01C8	$29CA			GOTO	$+2
$01C9	$29D1			GOTO	$+8
$01CA	$0BCB			DECFSZ	STACK_11, F
$01CB	$29CD			GOTO	$+2
$01CC	$29D0			GOTO	$+4
$01CD	$0BCA			DECFSZ	STACK_10, F
$01CE	$29CD			GOTO	$-1
$01CF	$29CA			GOTO	$-5
$01D0	$29C7			GOTO	$-9
$01D1	$3046			MOVLW	70
$01D2	$00CB			MOVWF	STACK_11
$01D3	$30FF			MOVLW	255
$01D4	$00CA			MOVWF	STACK_10
$01D5	$0BCB			DECFSZ	STACK_11, F
$01D6	$29D8			GOTO	$+2
$01D7	$29DB			GOTO	$+4
$01D8	$0BCA			DECFSZ	STACK_10, F
$01D9	$29D8			GOTO	$-1
$01DA	$29D5			GOTO	$-5
$01DB	$30CF			MOVLW	207
$01DC	$00CA			MOVWF	STACK_10
$01DD	$0BCA			DECFSZ	STACK_10, F
$01DE	$29DD			GOTO	$-1
$01DF	$0000			NOP
;TimerLed.c,115 :: 		EEprom_Write(3, Secondi / 0b11111111);
$01E0	$3003			MOVLW	3
$01E1	$00A4			MOVWF	FARG_EEprom_write+0
$01E2	$30FF			MOVLW	255
$01E3	$00C4			MOVWF	STACK_4
$01E4	$01C5			CLRF	STACK_4+1
$01E5	$081F			MOVF	FARG_Salva_Sec+0, 0
$01E6	$00C0			MOVWF	STACK_0
$01E7	$0820			MOVF	FARG_Salva_Sec+1, 0
$01E8	$00C1			MOVWF	STACK_0+1
$01E9	$208B			CALL	_div_16x16_s
$01EA	$0840			MOVF	STACK_0, 0
$01EB	$00A5			MOVWF	FARG_EEprom_write+1
$01EC	$2073			CALL	_EEprom_write
;TimerLed.c,116 :: 		}
$01ED	$0008			RETURN
$01EE	$	_main:
;TimerLed.c,118 :: 		void main (void)
;TimerLed.c,125 :: 		InitMCU();
$01EE	$20E5			CALL	_InitMCU
;TimerLed.c,126 :: 		uiMaxInterrupt = DEFAULT_TIME_INTERRUPT;
$01EF	$30C3			MOVLW	195
$01F0	$0097			MOVWF	main_uiMaxInterrupt_L0
$01F1	$0198			CLRF	main_uiMaxInterrupt_L0+1
;TimerLed.c,128 :: 		uiSecondi_Fine = Carica_Sec(); // Carico dalla EEPROM i secondi salvati
$01F2	$20F5			CALL	_Carica_Sec
$01F3	$0840			MOVF	STACK_0, 0
$01F4	$0092			MOVWF	_uiSecondi_Fine
$01F5	$0841			MOVF	STACK_0+1, 0
$01F6	$0093			MOVWF	_uiSecondi_Fine+1
;TimerLed.c,129 :: 		if (uiSecondi_Fine >= 585) uiSecondi_Fine = 30;
$01F7	$3002			MOVLW	2
$01F8	$0241			SUBWF	STACK_0+1, 0
$01F9	$1D03			BTFSS	STATUS, Z
$01FA	$29FD			GOTO	L_main_53
$01FB	$3049			MOVLW	73
$01FC	$0240			SUBWF	STACK_0, 0
$01FD	$	L_main_53:
$01FD	$1C03			BTFSS	STATUS, C
$01FE	$2A03			GOTO	L_main_12
$01FF	$301E			MOVLW	30
$0200	$0092			MOVWF	_uiSecondi_Fine
$0201	$3000			MOVLW	0
$0202	$0093			MOVWF	_uiSecondi_Fine+1
$0203	$	L_main_12:
;TimerLed.c,131 :: 		uiSecondi_Attuale = uiSecondi_Fine; // Setto il contatore dei secondi trascorsi
$0203	$0812			MOVF	_uiSecondi_Fine, 0
$0204	$008F			MOVWF	_uiSecondi_Attuale
$0205	$0813			MOVF	_uiSecondi_Fine+1, 0
$0206	$0090			MOVWF	_uiSecondi_Attuale+1
;TimerLed.c,133 :: 		Enable_Output(0);
$0207	$019F			CLRF	FARG_Enable_Output+0, 1
$0208	$212D			CALL	_Enable_Output
;TimerLed.c,134 :: 		Abilita_Timer(1);
$0209	$3001			MOVLW	1
$020A	$009F			MOVWF	FARG_Abilita_Timer+0
$020B	$2138			CALL	_Abilita_Timer
;TimerLed.c,137 :: 		while (1) {
$020C	$	L_main_13:
;TimerLed.c,138 :: 		DisplayNum();
$020C	$1303			BCF	STATUS, RP1
$020D	$1283			BCF	STATUS, RP0
$020E	$2143			CALL	_DisplayNum
;TimerLed.c,140 :: 		if (PORTA.F0 == 1) { //Pressione del tasto START/STOP
$020F	$3001			MOVLW	1
$0210	$0505			ANDWF	PORTA, 0
$0211	$00C2			MOVWF	STACK_2
$0212	$0842			MOVF	STACK_2, 0
$0213	$3A01			XORLW	1
$0214	$1D03			BTFSS	STATUS, Z
$0215	$2A7C			GOTO	L_main_15
;TimerLed.c,141 :: 		while (PORTA.F0 == 1) { DisplayNum(); } // Antirimbalzo
$0216	$	L_main_16:
$0216	$3001			MOVLW	1
$0217	$0505			ANDWF	PORTA, 0
$0218	$00C2			MOVWF	STACK_2
$0219	$0842			MOVF	STACK_2, 0
$021A	$3A01			XORLW	1
$021B	$1D03			BTFSS	STATUS, Z
$021C	$2A1F			GOTO	L_main_17
$021D	$2143			CALL	_DisplayNum
$021E	$2A16			GOTO	L_main_16
$021F	$	L_main_17:
;TimerLed.c,143 :: 		uiSecondi_Attuale = uiSecondi_Fine;
$021F	$0812			MOVF	_uiSecondi_Fine, 0
$0220	$008F			MOVWF	_uiSecondi_Attuale
$0221	$0813			MOVF	_uiSecondi_Fine+1, 0
$0222	$0090			MOVWF	_uiSecondi_Attuale+1
;TimerLed.c,144 :: 		Enable_Output(1);
$0223	$3001			MOVLW	1
$0224	$009F			MOVWF	FARG_Enable_Output+0
$0225	$212D			CALL	_Enable_Output
;TimerLed.c,145 :: 		Abilita_Timer(1);
$0226	$3001			MOVLW	1
$0227	$009F			MOVWF	FARG_Abilita_Timer+0
$0228	$2138			CALL	_Abilita_Timer
;TimerLed.c,147 :: 		while (uiSecondi_Attuale > 0) {
$0229	$	L_main_18:
$0229	$3080			MOVLW	128
$022A	$00C0			MOVWF	STACK_0
$022B	$3080			MOVLW	128
$022C	$0610			XORWF	_uiSecondi_Attuale+1, 0
$022D	$0240			SUBWF	STACK_0, 0
$022E	$1D03			BTFSS	STATUS, Z
$022F	$2A32			GOTO	L_main_54
$0230	$080F			MOVF	_uiSecondi_Attuale, 0
$0231	$3C00			SUBLW	0
$0232	$	L_main_54:
$0232	$1803			BTFSC	STATUS, C
$0233	$2A65			GOTO	L_main_19
;TimerLed.c,148 :: 		DisplayNum();
$0234	$2143			CALL	_DisplayNum
;TimerLed.c,149 :: 		if (uiContTmp >= uiMaxInterrupt) {
$0235	$0818			MOVF	main_uiMaxInterrupt_L0+1, 0
$0236	$020D			SUBWF	_uiContTmp+1, 0
$0237	$1D03			BTFSS	STATUS, Z
$0238	$2A3B			GOTO	L_main_55
$0239	$0817			MOVF	main_uiMaxInterrupt_L0, 0
$023A	$020C			SUBWF	_uiContTmp, 0
$023B	$	L_main_55:
$023B	$1C03			BTFSS	STATUS, C
$023C	$2A43			GOTO	L_main_20
;TimerLed.c,150 :: 		uiSecondi_Attuale--;
$023D	$3001			MOVLW	1
$023E	$028F			SUBWF	_uiSecondi_Attuale, 1
$023F	$1C03			BTFSS	STATUS, C
$0240	$0390			DECF	_uiSecondi_Attuale+1, 1
;TimerLed.c,151 :: 		uiContTmp = 0;  // Resetto il contatore di interrupt
$0241	$018C			CLRF	_uiContTmp
$0242	$018D			CLRF	_uiContTmp+1
;TimerLed.c,154 :: 		}
$0243	$	L_main_20:
;TimerLed.c,156 :: 		if ((PORTA.F0 == 1) && (uiSecondi_Attuale < uiSecondi_Fine - 3)){
$0243	$3001			MOVLW	1
$0244	$0505			ANDWF	PORTA, 0
$0245	$00C2			MOVWF	STACK_2
$0246	$0842			MOVF	STACK_2, 0
$0247	$3A01			XORLW	1
$0248	$1D03			BTFSS	STATUS, Z
$0249	$2A64			GOTO	L_main_23
$024A	$3003			MOVLW	3
$024B	$0212			SUBWF	_uiSecondi_Fine, 0
$024C	$00C2			MOVWF	STACK_2
$024D	$3000			MOVLW	0
$024E	$1C03			BTFSS	STATUS, C
$024F	$3F01			ADDLW	1
$0250	$0213			SUBWF	_uiSecondi_Fine+1, 0
$0251	$00C3			MOVWF	STACK_2+1
$0252	$0843			MOVF	STACK_2+1, 0
$0253	$0210			SUBWF	_uiSecondi_Attuale+1, 0
$0254	$1D03			BTFSS	STATUS, Z
$0255	$2A58			GOTO	L_main_56
$0256	$0842			MOVF	STACK_2, 0
$0257	$020F			SUBWF	_uiSecondi_Attuale, 0
$0258	$	L_main_56:
$0258	$1803			BTFSC	STATUS, C
$0259	$2A64			GOTO	L_main_23
$025A	$	L217_ex_L_main_23:
;TimerLed.c,157 :: 		while (PORTA.F0 == 1) { DisplayNum(); } // Antirimbalzo
$025A	$	L_main_24:
$025A	$3001			MOVLW	1
$025B	$0505			ANDWF	PORTA, 0
$025C	$00C2			MOVWF	STACK_2
$025D	$0842			MOVF	STACK_2, 0
$025E	$3A01			XORLW	1
$025F	$1D03			BTFSS	STATUS, Z
$0260	$2A63			GOTO	L_main_25
$0261	$2143			CALL	_DisplayNum
$0262	$2A5A			GOTO	L_main_24
$0263	$	L_main_25:
;TimerLed.c,158 :: 		break;
$0263	$2A65			GOTO	L_main_19
;TimerLed.c,159 :: 		}
$0264	$	L_main_23:
;TimerLed.c,160 :: 		}
$0264	$2A29			GOTO	L_main_18
$0265	$	L_main_19:
;TimerLed.c,161 :: 		Enable_Output(0);
$0265	$019F			CLRF	FARG_Enable_Output+0, 1
$0266	$212D			CALL	_Enable_Output
;TimerLed.c,162 :: 		Abilita_Timer(0);
$0267	$019F			CLRF	FARG_Abilita_Timer+0, 1
$0268	$2138			CALL	_Abilita_Timer
;TimerLed.c,163 :: 		uiSecondi_Attuale = uiSecondi_Fine;
$0269	$0812			MOVF	_uiSecondi_Fine, 0
$026A	$008F			MOVWF	_uiSecondi_Attuale
$026B	$0813			MOVF	_uiSecondi_Fine+1, 0
$026C	$0090			MOVWF	_uiSecondi_Attuale+1
;TimerLed.c,164 :: 		Delay_ms(100);
$026D	$3082			MOVLW	130
$026E	$00CB			MOVWF	STACK_11
$026F	$30FF			MOVLW	255
$0270	$00CA			MOVWF	STACK_10
$0271	$0BCB			DECFSZ	STACK_11, F
$0272	$2A74			GOTO	$+2
$0273	$2A77			GOTO	$+4
$0274	$0BCA			DECFSZ	STACK_10, F
$0275	$2A74			GOTO	$-1
$0276	$2A71			GOTO	$-5
$0277	$3087			MOVLW	135
$0278	$00CA			MOVWF	STACK_10
$0279	$0BCA			DECFSZ	STACK_10, F
$027A	$2A79			GOTO	$-1
$027B	$0000			NOP
;TimerLed.c,165 :: 		} // Fine tasto START/STOP
$027C	$	L_main_15:
;TimerLed.c,167 :: 		if (PORTA.F1 == 1) { // Pressione del tasto SET/STORE
$027C	$3000			MOVLW	0
$027D	$1885			BTFSC	PORTA, 1
$027E	$3001			MOVLW	1
$027F	$00C2			MOVWF	STACK_2
$0280	$0842			MOVF	STACK_2, 0
$0281	$3A01			XORLW	1
$0282	$1D03			BTFSS	STATUS, Z
$0283	$2B77			GOTO	L_main_26
;TimerLed.c,168 :: 		while (PORTA.F1 == 1) { DisplayNum(); } // Antirimbalzo
$0284	$	L_main_27:
$0284	$3000			MOVLW	0
$0285	$1885			BTFSC	PORTA, 1
$0286	$3001			MOVLW	1
$0287	$00C2			MOVWF	STACK_2
$0288	$0842			MOVF	STACK_2, 0
$0289	$3A01			XORLW	1
$028A	$1D03			BTFSS	STATUS, Z
$028B	$2A8E			GOTO	L_main_28
$028C	$2143			CALL	_DisplayNum
$028D	$2A84			GOTO	L_main_27
$028E	$	L_main_28:
;TimerLed.c,170 :: 		uiSecondi_Attuale = uiSecondi_Fine;
$028E	$0812			MOVF	_uiSecondi_Fine, 0
$028F	$008F			MOVWF	_uiSecondi_Attuale
$0290	$0813			MOVF	_uiSecondi_Fine+1, 0
$0291	$0090			MOVWF	_uiSecondi_Attuale+1
;TimerLed.c,172 :: 		while (1) { // Ciclo che termina quando si ripreme SET/STORE
$0292	$	L_main_29:
;TimerLed.c,174 :: 		DisplayNum();
$0292	$1303			BCF	STATUS, RP1
$0293	$1283			BCF	STATUS, RP0
$0294	$2143			CALL	_DisplayNum
;TimerLed.c,175 :: 		Delay_ms(10);
$0295	$300D			MOVLW	13
$0296	$00CB			MOVWF	STACK_11
$0297	$30FF			MOVLW	255
$0298	$00CA			MOVWF	STACK_10
$0299	$0BCB			DECFSZ	STACK_11, F
$029A	$2A9C			GOTO	$+2
$029B	$2A9F			GOTO	$+4
$029C	$0BCA			DECFSZ	STACK_10, F
$029D	$2A9C			GOTO	$-1
$029E	$2A99			GOTO	$-5
$029F	$30F3			MOVLW	243
$02A0	$00CA			MOVWF	STACK_10
$02A1	$0BCA			DECFSZ	STACK_10, F
$02A2	$2AA1			GOTO	$-1
$02A3	$0000			NOP
;TimerLed.c,177 :: 		cnt_incr = 0;
$02A4	$019D			CLRF	main_cnt_incr_L0
$02A5	$019E			CLRF	main_cnt_incr_L0+1
;TimerLed.c,179 :: 		while ((PORTA.F2 == 1) || (PORTA.F3 == 1)) {
$02A6	$	L_main_31:
$02A6	$3000			MOVLW	0
$02A7	$1905			BTFSC	PORTA, 2
$02A8	$3001			MOVLW	1
$02A9	$00C2			MOVWF	STACK_2
$02AA	$0842			MOVF	STACK_2, 0
$02AB	$3A01			XORLW	1
$02AC	$1903			BTFSC	STATUS, Z
$02AD	$2AB6			GOTO	L306_ex_L_main_32
$02AE	$3000			MOVLW	0
$02AF	$1985			BTFSC	PORTA, 3
$02B0	$3001			MOVLW	1
$02B1	$00C2			MOVWF	STACK_2
$02B2	$0842			MOVF	STACK_2, 0
$02B3	$3A01			XORLW	1
$02B4	$1D03			BTFSS	STATUS, Z
$02B5	$2B58			GOTO	L_main_32
$02B6	$	L306_ex_L_main_32:
;TimerLed.c,181 :: 		DisplayNum();
$02B6	$2143			CALL	_DisplayNum
;TimerLed.c,183 :: 		incr = 0;
$02B7	$019B			CLRF	main_incr_L0
$02B8	$019C			CLRF	main_incr_L0+1
;TimerLed.c,184 :: 		if (PORTA.F2 == 1) incr = 1;   // Se premo UP incremento di + 1
$02B9	$3000			MOVLW	0
$02BA	$1905			BTFSC	PORTA, 2
$02BB	$3001			MOVLW	1
$02BC	$00C2			MOVWF	STACK_2
$02BD	$0842			MOVF	STACK_2, 0
$02BE	$3A01			XORLW	1
$02BF	$1D03			BTFSS	STATUS, Z
$02C0	$2AC5			GOTO	L_main_35
$02C1	$3001			MOVLW	1
$02C2	$009B			MOVWF	main_incr_L0
$02C3	$3000			MOVLW	0
$02C4	$009C			MOVWF	main_incr_L0+1
$02C5	$	L_main_35:
;TimerLed.c,185 :: 		if (PORTA.F3 == 1) incr = -1;  // Se premo DOWN incremento di -1
$02C5	$3000			MOVLW	0
$02C6	$1985			BTFSC	PORTA, 3
$02C7	$3001			MOVLW	1
$02C8	$00C2			MOVWF	STACK_2
$02C9	$0842			MOVF	STACK_2, 0
$02CA	$3A01			XORLW	1
$02CB	$1D03			BTFSS	STATUS, Z
$02CC	$2AD1			GOTO	L_main_36
$02CD	$30FF			MOVLW	255
$02CE	$009B			MOVWF	main_incr_L0
$02CF	$30FF			MOVLW	255
$02D0	$009C			MOVWF	main_incr_L0+1
$02D1	$	L_main_36:
;TimerLed.c,187 :: 		cnt_incr++; // Tengo conto di quanto incremento
$02D1	$0A9D			INCF	main_cnt_incr_L0, 1
$02D2	$1903			BTFSC	STATUS, Z
$02D3	$0A9E			INCF	main_cnt_incr_L0+1, 1
;TimerLed.c,189 :: 		if ((uiSecondi_Attuale < 599) && (uiSecondi_Attuale >= 1))
$02D4	$3080			MOVLW	128
$02D5	$0610			XORWF	_uiSecondi_Attuale+1, 0
$02D6	$00C0			MOVWF	STACK_0
$02D7	$3080			MOVLW	128
$02D8	$3A02			XORLW	2
$02D9	$0240			SUBWF	STACK_0, 0
$02DA	$1D03			BTFSS	STATUS, Z
$02DB	$2ADE			GOTO	L_main_57
$02DC	$3057			MOVLW	87
$02DD	$020F			SUBWF	_uiSecondi_Attuale, 0
$02DE	$	L_main_57:
$02DE	$1803			BTFSC	STATUS, C
$02DF	$2AF2			GOTO	L_main_39
$02E0	$3080			MOVLW	128
$02E1	$0610			XORWF	_uiSecondi_Attuale+1, 0
$02E2	$00C0			MOVWF	STACK_0
$02E3	$3080			MOVLW	128
$02E4	$0240			SUBWF	STACK_0, 0
$02E5	$1D03			BTFSS	STATUS, Z
$02E6	$2AE9			GOTO	L_main_58
$02E7	$3001			MOVLW	1
$02E8	$020F			SUBWF	_uiSecondi_Attuale, 0
$02E9	$	L_main_58:
$02E9	$1C03			BTFSS	STATUS, C
$02EA	$2AF2			GOTO	L_main_39
$02EB	$	L337_ex_L_main_39:
;TimerLed.c,190 :: 		uiSecondi_Attuale = uiSecondi_Attuale + incr;
$02EB	$081B			MOVF	main_incr_L0, 0
$02EC	$078F			ADDWF	_uiSecondi_Attuale, 1
$02ED	$081C			MOVF	main_incr_L0+1, 0
$02EE	$1803			BTFSC	STATUS, C
$02EF	$3F01			ADDLW	1
$02F0	$0790			ADDWF	_uiSecondi_Attuale+1, 1
$02F1	$2AF6			GOTO	L_main_40
$02F2	$	L_main_39:
;TimerLed.c,192 :: 		uiSecondi_Attuale = 1;
$02F2	$3001			MOVLW	1
$02F3	$008F			MOVWF	_uiSecondi_Attuale
$02F4	$3000			MOVLW	0
$02F5	$0090			MOVWF	_uiSecondi_Attuale+1
$02F6	$	L_main_40:
;TimerLed.c,194 :: 		if (cnt_incr >= 15) incr = 10;
$02F6	$3000			MOVLW	0
$02F7	$021E			SUBWF	main_cnt_incr_L0+1, 0
$02F8	$1D03			BTFSS	STATUS, Z
$02F9	$2AFC			GOTO	L_main_59
$02FA	$300F			MOVLW	15
$02FB	$021D			SUBWF	main_cnt_incr_L0, 0
$02FC	$	L_main_59:
$02FC	$1C03			BTFSS	STATUS, C
$02FD	$2B02			GOTO	L_main_41
$02FE	$300A			MOVLW	10
$02FF	$009B			MOVWF	main_incr_L0
$0300	$3000			MOVLW	0
$0301	$009C			MOVWF	main_incr_L0+1
$0302	$	L_main_41:
;TimerLed.c,195 :: 		if (cnt_incr >= 30) incr = 20;
$0302	$3000			MOVLW	0
$0303	$021E			SUBWF	main_cnt_incr_L0+1, 0
$0304	$1D03			BTFSS	STATUS, Z
$0305	$2B08			GOTO	L_main_60
$0306	$301E			MOVLW	30
$0307	$021D			SUBWF	main_cnt_incr_L0, 0
$0308	$	L_main_60:
$0308	$1C03			BTFSS	STATUS, C
$0309	$2B0E			GOTO	L_main_42
$030A	$3014			MOVLW	20
$030B	$009B			MOVWF	main_incr_L0
$030C	$3000			MOVLW	0
$030D	$009C			MOVWF	main_incr_L0+1
$030E	$	L_main_42:
;TimerLed.c,196 :: 		if (cnt_incr >= 45) incr = 30;
$030E	$3000			MOVLW	0
$030F	$021E			SUBWF	main_cnt_incr_L0+1, 0
$0310	$1D03			BTFSS	STATUS, Z
$0311	$2B14			GOTO	L_main_61
$0312	$302D			MOVLW	45
$0313	$021D			SUBWF	main_cnt_incr_L0, 0
$0314	$	L_main_61:
$0314	$1C03			BTFSS	STATUS, C
$0315	$2B1A			GOTO	L_main_43
$0316	$301E			MOVLW	30
$0317	$009B			MOVWF	main_incr_L0
$0318	$3000			MOVLW	0
$0319	$009C			MOVWF	main_incr_L0+1
$031A	$	L_main_43:
;TimerLed.c,197 :: 		if (cnt_incr >= 60) incr = 40;
$031A	$3000			MOVLW	0
$031B	$021E			SUBWF	main_cnt_incr_L0+1, 0
$031C	$1D03			BTFSS	STATUS, Z
$031D	$2B20			GOTO	L_main_62
$031E	$303C			MOVLW	60
$031F	$021D			SUBWF	main_cnt_incr_L0, 0
$0320	$	L_main_62:
$0320	$1C03			BTFSS	STATUS, C
$0321	$2B26			GOTO	L_main_44
$0322	$3028			MOVLW	40
$0323	$009B			MOVWF	main_incr_L0
$0324	$3000			MOVLW	0
$0325	$009C			MOVWF	main_incr_L0+1
$0326	$	L_main_44:
;TimerLed.c,198 :: 		if (cnt_incr >= 90) incr = 45;
$0326	$3000			MOVLW	0
$0327	$021E			SUBWF	main_cnt_incr_L0+1, 0
$0328	$1D03			BTFSS	STATUS, Z
$0329	$2B2C			GOTO	L_main_63
$032A	$305A			MOVLW	90
$032B	$021D			SUBWF	main_cnt_incr_L0, 0
$032C	$	L_main_63:
$032C	$1C03			BTFSS	STATUS, C
$032D	$2B32			GOTO	L_main_45
$032E	$302D			MOVLW	45
$032F	$009B			MOVWF	main_incr_L0
$0330	$3000			MOVLW	0
$0331	$009C			MOVWF	main_incr_L0+1
$0332	$	L_main_45:
;TimerLed.c,200 :: 		for (i=0;i<50-incr;i++) { // Genero una pausa proporzionale
$0332	$0199			CLRF	main_i_L0
$0333	$019A			CLRF	main_i_L0+1
$0334	$	L_main_46:
$0334	$081B			MOVF	main_incr_L0, 0
$0335	$3C32			SUBLW	50
$0336	$00C2			MOVWF	STACK_2
$0337	$081C			MOVF	main_incr_L0+1, 0
$0338	$1C03			BTFSS	STATUS, C
$0339	$3F01			ADDLW	1
$033A	$01C3			CLRF	STACK_2+1
$033B	$02C3			SUBWF	STACK_2+1, 1
$033C	$0843			MOVF	STACK_2+1, 0
$033D	$021A			SUBWF	main_i_L0+1, 0
$033E	$1D03			BTFSS	STATUS, Z
$033F	$2B42			GOTO	L_main_64
$0340	$0842			MOVF	STACK_2, 0
$0341	$0219			SUBWF	main_i_L0, 0
$0342	$	L_main_64:
$0342	$1803			BTFSC	STATUS, C
$0343	$2B57			GOTO	L_main_47
;TimerLed.c,201 :: 		DisplayNum();          // a quanto ho incrementato i tempi
$0344	$2143			CALL	_DisplayNum
;TimerLed.c,202 :: 		Delay_ms(1);
$0345	$3002			MOVLW	2
$0346	$00CB			MOVWF	STACK_11
$0347	$30FF			MOVLW	255
$0348	$00CA			MOVWF	STACK_10
$0349	$0BCB			DECFSZ	STACK_11, F
$034A	$2B4C			GOTO	$+2
$034B	$2B4F			GOTO	$+4
$034C	$0BCA			DECFSZ	STACK_10, F
$034D	$2B4C			GOTO	$-1
$034E	$2B49			GOTO	$-5
$034F	$304A			MOVLW	74
$0350	$00CA			MOVWF	STACK_10
$0351	$0BCA			DECFSZ	STACK_10, F
$0352	$2B51			GOTO	$-1
;TimerLed.c,203 :: 		}
$0353	$	L_main_48:
;TimerLed.c,200 :: 		for (i=0;i<50-incr;i++) { // Genero una pausa proporzionale
$0353	$0A99			INCF	main_i_L0, 1
$0354	$1903			BTFSC	STATUS, Z
$0355	$0A9A			INCF	main_i_L0+1, 1
;TimerLed.c,203 :: 		}
$0356	$2B34			GOTO	L_main_46
$0357	$	L_main_47:
;TimerLed.c,205 :: 		} // Fine del ciclo del tasto UP o DOWN
$0357	$2AA6			GOTO	L_main_31
$0358	$	L_main_32:
;TimerLed.c,207 :: 		if (PORTA.F1 == 1) { // Seconda pressione del tasto SET/STORE
$0358	$3000			MOVLW	0
$0359	$1885			BTFSC	PORTA, 1
$035A	$3001			MOVLW	1
$035B	$00C2			MOVWF	STACK_2
$035C	$0842			MOVF	STACK_2, 0
$035D	$3A01			XORLW	1
$035E	$1D03			BTFSS	STATUS, Z
$035F	$2B74			GOTO	L_main_49
;TimerLed.c,208 :: 		while (PORTA.F1 == 1) { DisplayNum(); } // Antirimbalzo
$0360	$	L_main_50:
$0360	$3000			MOVLW	0
$0361	$1885			BTFSC	PORTA, 1
$0362	$3001			MOVLW	1
$0363	$00C2			MOVWF	STACK_2
$0364	$0842			MOVF	STACK_2, 0
$0365	$3A01			XORLW	1
$0366	$1D03			BTFSS	STATUS, Z
$0367	$2B6A			GOTO	L_main_51
$0368	$2143			CALL	_DisplayNum
$0369	$2B60			GOTO	L_main_50
$036A	$	L_main_51:
;TimerLed.c,209 :: 		uiSecondi_Fine = uiSecondi_Attuale;
$036A	$080F			MOVF	_uiSecondi_Attuale, 0
$036B	$0092			MOVWF	_uiSecondi_Fine
$036C	$0810			MOVF	_uiSecondi_Attuale+1, 0
$036D	$0093			MOVWF	_uiSecondi_Fine+1
;TimerLed.c,210 :: 		Salva_Sec(uiSecondi_Fine);
$036E	$080F			MOVF	_uiSecondi_Attuale, 0
$036F	$009F			MOVWF	FARG_Salva_Sec+0
$0370	$0810			MOVF	_uiSecondi_Attuale+1, 0
$0371	$00A0			MOVWF	FARG_Salva_Sec+1
$0372	$21B9			CALL	_Salva_Sec
;TimerLed.c,211 :: 		break;
$0373	$2B77			GOTO	L_main_30
;TimerLed.c,212 :: 		}
$0374	$	L_main_49:
;TimerLed.c,214 :: 		} // Fine del ciclo di SET/STORE
$0374	$1303			BCF	STATUS, RP1
$0375	$1683			BSF	STATUS, RP0
$0376	$2A92			GOTO	L_main_29
$0377	$	L_main_30:
;TimerLed.c,215 :: 		} // Fine del tasto SET/STORE
$0377	$	L_main_26:
;TimerLed.c,217 :: 		} // Fine del Loop Principale
$0377	$1303			BCF	STATUS, RP1
$0378	$1683			BSF	STATUS, RP0
$0379	$2A0C			GOTO	L_main_13
;TimerLed.c,218 :: 		}
$037A	$2B7A			GOTO	$
